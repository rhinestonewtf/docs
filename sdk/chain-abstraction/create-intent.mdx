---
title: "Create an Intent"
description: "Learn how to create and execute multi-chain intents with Rhinestone."
---

import SnippetOmnichainTransactions from '/snippets/omnichain-transactions.mdx';

## Overview

Intents are expressions of desired outcomes that sophisticated third-party actors fulfill. These third-party actors are often referred to as **solvers** or **relayers**. Importantly, intents are chain-agnostic. With the right settlement infrastructure and relayer marketplace, intents enable fast, cheap, and generalized executions to happen on any chain.

Rhinestone's intent system is a modular engine that aggregates settlement layers through one unified relayer market. It utilizes resource locks for asynchronous execution and blazing-fast speed.

<Note>The intent system uses the core `sendTransaction` API. Some advanced features shown in examples may require additional implementation based on your account setup and the current intent system capabilities.</Note>

**What makes intents powerful:**
- Express desired outcomes, not execution steps
- Unified relayer market aggregates settlement layers
- Atomic and deterministic cross-chain execution
- Single signature for multi-chain, multi-token operations

## Intent Fundamentals

### Intent Structure

Every intent is composed of **Elements**, where each Element represents a chain-specific commitment. An Element defines the settlement layer, chain ID, and locked token information, along with a **Mandate** that specifies the recipient, output tokens, expiry, and the destination chain.

```tsx
const intent = {
  sourceChains: [arbitrum, base], // Origin chains with available tokens
  targetChain: ethereum,          // Destination chain for execution
  calls: [...],                   // Destination chain executions
  tokenRequests: [...],           // Required output tokens
  // Optional: origin chain executions (pre-claim operations)
}
```

**Key concepts:**
- **Elements**: Chain-specific commitments with settlement layer info
- **Mandate**: Defines recipient, output tokens, and destination execution
- **Origin executions**: Pre-claim operations before settlement
- **Destination executions**: Operations executed after token delivery

### Basic Cross-Chain Transfer

The simplest intent - move tokens from one chain to another:

```tsx
const transferIntent = await rhinestoneAccount.sendTransaction({
  sourceChains: [arbitrum],
  targetChain: base,
  calls: [
    {
      to: baseUSDC,
      data: encodeFunctionData({
        abi: erc20Abi,
        functionName: 'transfer',
        args: [recipient, amount],
      }),
    },
  ],
  tokenRequests: [
    {
      address: baseUSDC,
      amount: parseUnits('100', 6), // 100 USDC
    },
  ],
})
```

### Single-Chain Transaction

Execute on one chain using local tokens:

```tsx
const singleChainTx = await rhinestoneAccount.sendTransaction({
  chain: ethereum,
  calls: [
    {
      to: tokenAddress,
      data: encodeFunctionData({
        abi: erc20Abi,
        functionName: 'transfer',
        args: [recipient, parseUnits('1', 18)],
      }),
    },
  ],
})
```

## Monitor Execution

```tsx
const result = await rhinestoneAccount.waitForExecution(transferIntent)
console.log('Status:', result.status)
```

<SnippetOmnichainTransactions />