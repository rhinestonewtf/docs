---
title: "JIT vs Resource Locks"
description: "Understanding Rhinestone's dual-mode execution: Just-In-Time flow versus Fill-First flow with The Compact."
---

## Overview

Rhinestone's intent system supports two distinct execution flows, each optimized for different use cases, chain conditions, and UX expectations: the **Fill-First flow** (which utilizes resource locks via The Compact) and the **Just-in-Time (JIT) flow** (which always processes claim transactions on the origin chain(s) first).

**Key differences:**
- **JIT Flow**: Claims processed first, then fills executed - ideal for complex DeFi interactions
- **Fill-First Flow**: Pre-locked funds enable instantaneous fills, then claims processed - optimized for blazing-fast UX
- **The Compact**: An ownerless ERC-6909 contract that facilitates escrow-based resource locks

## Execution Strategies

### Just-In-Time (JIT) Flow

In the JIT flow, the system begins by processing claims across all relevant origin chains. These claims are submitted by relayers and executed using standard proof mechanisms provided by the selected settlement layer.

Only once all origin claims have been successfully processed is the fill performed on the destination chain.

The key advantage of this model is that user funds do not need to be pre-locked in a resource contract like The Compact. Instead, user signatures and the settlement layer's integrity (via proof systems or bridging assumptions) act as the enforcement mechanism.

```tsx
// Standard intent execution (uses JIT by default)
const jitIntent = await rhinestoneAccount.sendTransaction({
  sourceChains: [arbitrum, polygon],
  targetChain: ethereum,
  calls: [
    {
      to: compoundUSDC,
      data: encodeFunctionData({
        abi: compoundAbi,
        functionName: 'supply',
        args: [parseUnits('1000', 6)],
      }),
    },
  ],
  tokenRequests: [
    {
      address: ethereumUSDC,
      amount: parseUnits('1000', 6),
    },
  ],
})

// JIT Execution flow:
// 1. Intent submitted to orchestrator
// 2. Relayers compete in the relayer market
// 3. Claims processed on origin chains first
// 4. Proof/settlement verification
// 5. Fill executed on destination chain
```

### Fill-First Flow

The Fill-First flow flips the process for one core goal: blazing-fast UX.

The user pre-locks funds into The Compact. Once that lock is in place, relayers can immediately execute the fill on the destination chain without waiting for origin claims to be confirmed.

After the fill has completed, relayers then return to the origin chains to claim the corresponding funds, using the original intent signature as a credible, onchain commitment. Since the user's intent was pre-authorized, the system guarantees that only valid fills can trigger unlocks from The Compact.

```tsx
// UserOp execution (uses resource locking)
const lockedIntent = await rhinestoneAccount.sendTransaction({
  sourceChains: [base],
  targetChain: arbitrum,
  calls: [
    {
      to: arbitrumUSDC,
      data: encodeFunctionData({
        abi: erc20Abi,
        functionName: 'transfer',
        args: [recipient, parseUnits('500', 6)],
      }),
    },
  ],
  tokenRequests: [
    {
      address: arbitrumUSDC,
      amount: parseUnits('500', 6),
    },
  ],
  // Fill-First flow configuration
  preDepositFunds: true, // Pre-lock funds in The Compact
})

// Fill-First execution flow:
// 1. Funds pre-locked in The Compact
// 2. Relayer executes fill immediately on destination
// 3. Fill transaction completes (1-2 seconds)
// 4. Relayer processes claims on origin chains
// 5. Compact unlocks claimed funds to relayer
```

## When Each Flow is Used

### JIT Flow Use Cases

This approach makes the JIT flow ideal for complex DeFi interactions that span multiple chains, or intents that require dynamic conditions to be validated before execution:

```tsx
// 1. Standard intent execution (no session keys)
const standardIntent = await rhinestoneAccount.sendTransaction({
  sourceChains: [ethereum],
  targetChain: polygon,
  calls: [...],
  // No signers specified = JIT execution
})

// 2. Owner-signed transactions
const ownerIntent = await rhinestoneAccount.sendTransaction({
  sourceChains: [arbitrum],
  targetChain: base,
  calls: [...],
  signers: {
    type: 'owner',
    kind: 'ecdsa',
    accounts: [ownerAccount],
  },
})

// 3. Cross-chain intents (preferred for efficiency)
const crossChainIntent = await rhinestoneAccount.sendTransaction({
  sourceChains: [ethereum, arbitrum, polygon], // Multiple source chains
  targetChain: optimism,
  calls: [...],
})
```

### Fill-First Flow Use Cases

The Fill-First flow is optimized for blazing-fast UX where users want near-instantaneous execution:

```tsx
// 1. Session key execution
const sessionIntent = await rhinestoneAccount.sendTransaction({
  sourceChains: [polygon],
  targetChain: arbitrum,
  calls: [...],
  signers: {
    type: 'session',
    session: {
      owners: {
        type: 'ecdsa',
        accounts: [sessionKeyAccount],
      },
      policies: [...],
    },
  },
})

// 2. Guardian recovery operations
const guardianIntent = await rhinestoneAccount.sendTransaction({
  sourceChains: [ethereum],
  targetChain: arbitrum,
  calls: [...],
  signers: {
    type: 'guardians',
    guardians: [guardian1, guardian2],
  },
})

// 3. UserOp-required operations
const userOpIntent = await rhinestoneAccount.sendTransaction({
  sourceChains: [base],
  targetChain: optimism,
  calls: [...],
  // Any configuration that requires UserOp flow
  requireUserOp: true,
})
```

## Fund Management Implications

### JIT (Unlocked Funds)

Your funds remain available until execution:

```tsx
// Check unlocked vs locked balances
const portfolio = await rhinestoneAccount.getPortfolio()

portfolio.forEach(token => {
  console.log(`${token.symbol}:`, {
    unlocked: token.balances.unlocked, // Available for JIT execution
    locked: token.balances.locked,     // Reserved for pending operations
    total: token.balances.unlocked + token.balances.locked,
  })
})

// Benefits of JIT:
// ✅ Funds stay liquid until needed
// ✅ Can cancel intents before execution
// ✅ Optimal routing through solver competition
// ✅ Lower latency for simple operations
```

### Resource Locking (Locked Funds)

Funds are immediately reserved:

```tsx
// Funds locked immediately on submission
const intentWithLocks = await rhinestoneAccount.sendTransaction({
  sourceChains: [ethereum],
  targetChain: arbitrum,
  calls: [...],
  signers: { type: 'session', session: sessionKey },
})

// Check locked amounts
const balanceAfterLock = await rhinestoneAccount.getPortfolio()
console.log('Locked for intent:', {
  intentId: intentWithLocks.id,
  lockedAmounts: balanceAfterLock.reduce((acc, token) => {
    if (token.balances.locked > 0n) {
      acc[token.symbol] = token.balances.locked
    }
    return acc
  }, {}),
})

// Benefits of resource locking:
// ✅ Guaranteed fund availability
// ✅ Predictable execution timing
// ✅ Better for automated/session operations
// ✅ Prevents double-spending in automation
```

## Choosing the Right Strategy

### Use JIT When:

- **Interactive operations**: User is present to sign
- **Cross-chain arbitrage**: Need optimal routing
- **Large transactions**: Benefit from solver competition
- **Flexible timing**: Can wait for best execution

```tsx
// Ideal for JIT: Large cross-chain DeFi operation
const defiIntent = await rhinestoneAccount.sendTransaction({
  sourceChains: [ethereum, arbitrum, polygon], // Multiple sources
  targetChain: optimism,
  calls: [
    // Complex DeFi operation
    {
      to: velodromRouter,
      data: encodeFunctionData({
        abi: routerAbi,
        functionName: 'swapExactTokensForTokens',
        args: [amount, minOut, path, recipient, deadline],
      }),
    },
  ],
  tokenRequests: [
    {
      address: optimismUSDC,
      amount: parseUnits('10000', 6), // Large amount benefits from competition
    },
  ],
})
```

### Use Resource Locking When:

- **Automated operations**: Session keys or guardians
- **Time-sensitive**: Need guaranteed execution
- **Regulated flows**: Require audit trails
- **Batch processing**: Multiple related operations

```tsx
// Ideal for locking: Automated DCA with session keys
const dcaIntent = await rhinestoneAccount.sendTransaction({
  sourceChains: [base],
  targetChain: ethereum,
  calls: [
    {
      to: uniswapV3Router,
      data: encodeFunctionData({
        abi: uniswapAbi,
        functionName: 'exactInputSingle',
        args: [dcaParams],
      }),
    },
  ],
  tokenRequests: [
    {
      address: ethereumWETH,
      amount: parseUnits('0.1', 18), // Regular DCA amount
    },
  ],
  signers: {
    type: 'session',
    session: dcaSessionKey, // Automated execution
  },
})
```

## Monitoring and Analytics

### Track Execution Strategies

Monitor which strategy is being used:

```tsx
const intentDetails = await rhinestoneAccount.getIntentStatus(intent.id)

console.log('Execution strategy:', {
  strategy: intentDetails.executionStrategy, // 'JIT' | 'LOCKED'
  fundSource: intentDetails.fundSource,      // 'unlocked' | 'locked'
  lockTimestamp: intentDetails.lockTimestamp,
  unlockTimestamp: intentDetails.unlockTimestamp,
})

// For resource-locked intents
if (intentDetails.executionStrategy === 'LOCKED') {
  console.log('Lock details:', {
    lockedAmounts: intentDetails.lockedAmounts,
    lockDuration: intentDetails.unlockTimestamp - intentDetails.lockTimestamp,
    autoUnlockEnabled: intentDetails.autoUnlockEnabled,
  })
}
```

### Performance Comparison

Compare strategies for your use case:

```tsx
// Analyze past intents
const intentHistory = await rhinestoneAccount.getIntentHistory({
  limit: 100,
  includeMetrics: true,
})

const jitIntents = intentHistory.filter(i => i.executionStrategy === 'JIT')
const lockedIntents = intentHistory.filter(i => i.executionStrategy === 'LOCKED')

console.log('Strategy comparison:', {
  jit: {
    avgExecutionTime: average(jitIntents.map(i => i.executionTime)),
    avgCost: average(jitIntents.map(i => i.totalCost)),
    successRate: jitIntents.filter(i => i.status === 'COMPLETED').length / jitIntents.length,
  },
  locked: {
    avgExecutionTime: average(lockedIntents.map(i => i.executionTime)),
    avgCost: average(lockedIntents.map(i => i.totalCost)),
    successRate: lockedIntents.filter(i => i.status === 'COMPLETED').length / lockedIntents.length,
  },
})
```

## Error Handling

### JIT Execution Errors

```tsx
try {
  const jitIntent = await rhinestoneAccount.sendTransaction({...})
} catch (error) {
  if (error.code === 'INSUFFICIENT_UNLOCKED_BALANCE') {
    console.log('Not enough unlocked funds for JIT execution')
    // Wait for pending operations to complete or add more funds
  } else if (error.code === 'NO_SOLVER_AVAILABLE') {
    console.log('No solvers willing to fulfill this intent')
    // Adjust parameters or try resource locking
  }
}
```

### Resource Locking Errors

```tsx
try {
  const lockedIntent = await rhinestoneAccount.sendTransaction({
    signers: { type: 'session', session: sessionKey },
    ...
  })
} catch (error) {
  if (error.code === 'INSUFFICIENT_BALANCE_FOR_LOCK') {
    console.log('Cannot lock required funds')
    // Check total balance vs required amount
  } else if (error.code === 'LOCK_TIMEOUT') {
    console.log('Lock operation timed out')
    // Retry or use JIT execution
  }
}
```

## Best Practices

### 1. Strategy Selection

```tsx
// Choose based on use case
const strategy = userPresent && !automated 
  ? 'JIT'           // Interactive operations
  : 'RESOURCE_LOCK' // Automated operations

const intent = await rhinestoneAccount.sendTransaction({
  sourceChains: [ethereum],
  targetChain: arbitrum,
  calls: [...],
  signers: strategy === 'RESOURCE_LOCK' 
    ? { type: 'session', session: sessionKey }
    : undefined, // JIT execution
})
```

### 2. Balance Management

```tsx
// Maintain appropriate unlocked/locked ratios
const portfolio = await rhinestoneAccount.getPortfolio()
const totalBalance = portfolio[0].balances.unlocked + portfolio[0].balances.locked
const lockRatio = portfolio[0].balances.locked / totalBalance

if (lockRatio > 0.8) {
  console.warn('Too many funds locked - consider optimizing session operations')
}
```

### 3. Monitoring and Optimization

```tsx
// Regular balance monitoring
setInterval(async () => {
  const portfolio = await rhinestoneAccount.getPortfolio()
  const metrics = calculateBalanceMetrics(portfolio)
  
  if (metrics.inefficientLocks > 0) {
    console.log('Consider releasing unused locks:', metrics.inefficientLocks)
  }
}, 60000) // Check every minute
```

## Next Steps

- Learn about [injected executions](./injected-executions) for understanding execution injection
- Explore [create intent](./create-intent) for basic intent creation patterns
- See [solver-based swaps](../chain-abstraction/solver-based-swaps) for advanced execution logic
- Check out [session keys](../smart-sessions/overview) for automated operation setup
