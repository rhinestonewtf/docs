---
title: "Injected Executions"
description: "Understand injected executions in Rhinestone's intent system for sophisticated cross-chain operations."
---

## Overview

Rhinestone's intent system supports both **origin chain** and **destination chain** executions as part of a single intent. These executions enable sophisticated cross-chain operations by allowing the orchestrator to inject additional operations during the fulfillment process.

**Key concepts:**
- **Origin executions**: User-authorized operations that run before funds are deposited into the settlement layer
- **Destination executions**: Operations executed after tokens are delivered on the destination chain
- **Automatic injection**: The Orchestrator determines when additional operations are needed for optimal routing
- **Settlement integration**: Seamless coordination with multiple settlement layers and DeFi protocols

## How Injected Executions Work

### Execution Flow

```
1. Intent Submission → 2. Origin Executions → 3. Settlement Layer Deposit → 4. Cross-Chain Settlement → 5. Destination Executions
```

The orchestrator analyzes your intent and determines where additional operations are needed for optimal execution:

### Origin Chain Executions

Operations that happen before funds are deposited into the settlement layer. For example, if a user wishes to fund their intent using a token that is not supported by the settlement layer and relayer market, origin logic could include a swap into the correct token type.

```tsx
// Example: WETH unwrapping on source chain before bridging
const intent = await rhinestoneAccount.sendTransaction({
  sourceChains: [ethereum],
  targetChain: arbitrum,
  calls: [
    {
      to: arbitrumUSDC,
      data: encodeFunctionData({
        abi: erc20Abi,
        functionName: 'transfer',
        args: [recipient, amount],
      }),
    },
  ],
  tokenRequests: [
    {
      address: arbitrumUSDC,
      amount: parseUnits('1000', 6),
    },
  ],
})

// The orchestrator might inject:
// 1. WETH → ETH unwrap on Ethereum
// 2. ETH → USDC swap on Ethereum  
// 3. Bridge USDC to Arbitrum
// 4. Execute your transfer on Arbitrum
```

### Destination Chain Executions

Once the destination chain receives the proof (or fulfills the trust assumption) of a claim, the Intent Router ensures the user's tokens are delivered and their intent — such as interacting with a DeFi contract — is executed atomically and in the correct order. This includes enforcing timeouts, preventing misordered execution, and deploying the user's account on-the-fly if it hasn't yet been instantiated (supporting counterfactual accounts).

```tsx
// Example: Account deployment + token transfer
const intent = await rhinestoneAccount.sendTransaction({
  sourceChains: [base],
  targetChain: polygon,
  calls: [
    {
      to: polygonUSDC,
      data: encodeFunctionData({
        abi: erc20Abi,
        functionName: 'transfer',
        args: [recipient, amount],
      }),
    },
  ],
  tokenRequests: [
    {
      address: polygonUSDC,
      amount: parseUnits('500', 6),
    },
  ],
})

// The orchestrator might inject:
// 1. Deploy smart account on Polygon (if not deployed)
// 2. Setup account modules (if needed)
// 3. Execute your token transfer
```

## Types of Injected Executions

### 1. Token Operations

Automatic token handling for optimal routing:

```tsx
// WETH wrapping/unwrapping
const wrapExecution = {
  to: wethAddress,
  data: encodeFunctionData({
    abi: wethAbi,
    functionName: 'deposit',
    args: [],
  }),
  value: parseEther('1'),
}

// Token approvals for DEX interactions
const approvalExecution = {
  to: tokenAddress,
  data: encodeFunctionData({
    abi: erc20Abi,
    functionName: 'approve',
    args: [spenderAddress, amount],
  }),
}
```

### 2. Account Management

Smart account lifecycle operations:

```tsx
// Account deployment on new chains
const deploymentExecution = {
  to: accountFactory,
  data: encodeFunctionData({
    abi: factoryAbi,
    functionName: 'createAccount',
    args: [owner, salt],
  }),
}

// Module installation
const moduleInstallation = {
  to: accountAddress,
  data: encodeFunctionData({
    abi: accountAbi,
    functionName: 'installModule',
    args: [moduleType, moduleAddress, initData],
  }),
}
```

### 3. Protocol Interactions

DeFi protocol setup and interactions:

```tsx
// Compound supply setup
const compoundSetup = [
  {
    to: usdcAddress,
    data: encodeFunctionData({
      abi: erc20Abi,
      functionName: 'approve',
      args: [compoundUSDC, amount],
    }),
  },
  {
    to: compoundUSDC,
    data: encodeFunctionData({
      abi: compoundAbi,
      functionName: 'supply',
      args: [amount],
    }),
  },
]
```

## Automatic Injection Logic

The orchestrator automatically determines when to inject executions based on:

### Smart Account Status

```tsx
// If account not deployed on target chain
if (accountStatus === 'NOT_DEPLOYED') {
  // Inject deployment operations
  injectedExecutions.push(deploymentExecution)
}

// If required modules not installed
if (!hasRequiredModules) {
  // Inject module installation
  injectedExecutions.push(moduleInstallation)
}
```

### Token Requirements

```tsx
// If WETH needed but only ETH available
if (needsWETH && hasETH) {
  // Inject WETH wrapping
  injectedExecutions.push(wrapExecution)
}

// If token approval needed for DEX
if (needsApproval) {
  // Inject approval transaction
  injectedExecutions.push(approvalExecution)
}
```

### Route Optimization

```tsx
// If better route available through DEX
if (dexRouteMoreEfficient) {
  // Inject swap operations
  injectedExecutions.push(...swapExecutions)
}

// If multi-hop needed for best price
if (multiHopBetter) {
  // Inject intermediate swaps
  injectedExecutions.push(...multiHopExecutions)
}
```

## Working with Injected Executions

### Trust and Validation

Injected executions are automatically validated by the orchestrator:

```tsx
// All injected executions are:
// 1. Deterministic based on your intent
// 2. Optimized for cost and efficiency  
// 3. Validated for security
// 4. Signed by you before execution

const intentWithInjections = await rhinestoneAccount.sendTransaction({
  // Your intent specification
  sourceChains: [ethereum],
  targetChain: arbitrum,
  calls: [...],
  tokenRequests: [...],
})

// You sign the complete bundle including injections
// before any execution happens
```

### Monitoring Injected Operations

Track the complete execution flow:

```tsx
// Get detailed execution information
const intentStatus = await rhinestoneAccount.getIntentStatus(intent.id)

console.log('All operations:', {
  preClaimOps: intentStatus.preClaimOperations,
  bridgeOps: intentStatus.bridgeOperations,
  destinationOps: intentStatus.destinationOperations,
  injectedOps: intentStatus.injectedOperations,
})

// Monitor individual operation status
intentStatus.operations.forEach((op, index) => {
  console.log(`Operation ${index}:`, {
    type: op.type, // 'user' | 'injected'
    status: op.status,
    txHash: op.transactionHash,
    gasUsed: op.gasUsed,
  })
})
```

### Gas Estimation with Injections

The orchestrator estimates gas for all operations:

```tsx
// Estimate includes all injected operations
const gasEstimate = await rhinestoneAccount.estimateGas({
  sourceChains: [ethereum],
  targetChain: arbitrum,
  calls: [...],
  tokenRequests: [...],
})

console.log('Gas breakdown:', {
  userOperations: gasEstimate.userGas,
  injectedOperations: gasEstimate.injectedGas,
  totalGas: gasEstimate.totalGas,
  estimatedCost: gasEstimate.totalCostUSD,
})
```

## Advanced Patterns

### Custom Injection Hints

Provide hints to optimize injections:

```tsx
const optimizedIntent = await rhinestoneAccount.sendTransaction({
  sourceChains: [ethereum],
  targetChain: arbitrum,
  calls: [...],
  tokenRequests: [...],
  optimizationHints: {
    preferDEXRouting: true,
    maxSlippage: 0.5, // 0.5%
    prioritizeSpeed: false, // Optimize for cost
  },
})
```

### Batch Operations

Combine multiple intents with shared injections:

```tsx
const batchIntent = await rhinestoneAccount.sendTransaction({
  sourceChains: [ethereum, polygon],
  targetChain: arbitrum,
  calls: [
    // Multiple operations that can share setup
    ...defiOperations,
    ...nftOperations,
  ],
  tokenRequests: [...],
  batchOptimization: true, // Share injection costs
})
```

## Security Considerations

### Injection Validation

All injected executions are:

1. **Deterministic**: Same input always produces same injections
2. **Minimal**: Only necessary operations are injected
3. **Validated**: All operations pass security checks
4. **Transparent**: You can inspect before signing

### User Control

You maintain full control:

```tsx
// Review injections before signing
const intentPreview = await rhinestoneAccount.previewIntent({
  sourceChains: [ethereum],
  targetChain: arbitrum,
  calls: [...],
  tokenRequests: [...],
})

console.log('Will inject:', intentPreview.injectedExecutions)

// Proceed only if you approve
if (userApproves(intentPreview.injectedExecutions)) {
  const intent = await rhinestoneAccount.executeIntent(intentPreview)
}
```

## Next Steps

- Learn about [injected swaps](./injected-swaps) for complex trading strategies
- Understand [JIT vs resource locks](./jit-vs-resource-locks) for execution optimization
- Explore [solver-based swaps](../chain-abstraction/solver-based-swaps) for custom execution logic
- See [account deployment](../chain-abstraction/account-deployment) for cross-chain account management
