---
title: "Single-Chain Intent"
description: "Use intents to create same-chain transactions"
---

Single-chain intents let you make transactions on a chain of your choice.

These intents are similar to ERC-4337 User Operations. See our [concepts section on intents vs userops](../../home/concepts/intents-and-erc4337) to better understand the difference.

Relayers execute single-chain intents through the intent executor module. For a breakdown of the high-level flow, please take a look at the [Rhinestone Intents concepts section](../../home/introduction/rhinestone-intents).

## Example

Here's how you can make a token transfer:

```ts
const singleChainTx = await rhinestoneAccount.sendTransaction({
  chain: base,
  calls: [
    {
      to: 'USDC',
      data: encodeFunctionData({
        abi: erc20Abi,
        functionName: 'transfer',
        args: [recipient, parseUnits('5', 6)],
      }),
    },
  ],
})
```

## Gas Limit

You can override the default gas limit for the target chain execution with `gasLimit`. Doing this will make the intent better priced, because we can more accurately calculate the fee that a solver needs to be reimbursed with for paying the gas. If this is not provided, we calculate using a gas limit of `1_000_000`.

```ts {9}
const transaction = await rhinestoneAccount.sendTransaction({
  chain: base,
  calls: [
    // …
  ],
  tokenRequests: [
    // …
  ],
  gasLimit: 200_000n,
})
```

## Source Assets

You can specify what token (or tokens) to use as an input asset:

```ts {9}
const transaction = await rhinestoneAccount.sendTransaction({
  chain: base,
  calls: [
    // …
  ],
  tokenRequests: [
    // …
  ],
  sourceAssets: ['USDC', 'ETH']
})
```

## Fee Asset

You can choose what asset to use as a fee token (i.e., to cover gas and bridging fees):

```ts {9}
const transaction = await rhinestoneAccount.sendTransaction({
  chain: base,
  calls: [
    // …
  ],
  tokenRequests: [
    // …
  ],
  feeAsset: 'USDC',
})
```

## Wait for Execution

`sendTransaction` returns a pending intent. To wait until it gets executed, use `waitForExecution`:

```ts
const transaction = await rhinestoneAccount.sendTransaction({
  // …
})
const transactionResult = await rhinestoneAccount.waitForExecution(transaction)
```

By default, intents are pre-confirmed by a relayer to be executed before they actually land onchain. You can opt out of this by waiting for onchain execution:

```ts
const acceptPreconfirmations = false;
const transactionResult = await rhinestoneAccount.waitForExecution(transaction, acceptPreconfirmations)
```
