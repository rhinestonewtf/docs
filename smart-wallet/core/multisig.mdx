---
title: "Multisig"
description: "Setup an m-of-n passkeys or ECDSA multisig."
---

## Overview

A multisig account requires multiple signatures from a predefined set of authorized parties to approve and execute transactions. Unlike single-signature setups, where one keyholder controls the account, multisig enhances security and trust by distributing control among multiple stakeholders. 

In most common cases, multisig is used to ensure that no single party can act unilaterally, reducing the risk of theft, loss, or misuse of funds. However, in some cases multisigs can also be used to improve the user experience. For example, when using passkeys a common headache is that passkeys are not portable between devices. Therefore, in order to provide a seamless experience a new passkey signer must be added for each new device, creating a 1-of-1+n(devices) setup.

Both our [ECDSA signer](./ecdsa-signer) (Ownable Validator) and [passkeys signer](./passkeys) (WebAuthn Validator) support multisig by verifying individual signatures, while the smart account enforces the required threshold (e.g., 2-of-3 signatures).

### How it works

* **Mechanism**: The Ownable Validator or WebAuthn Validator stores a list of owner addresses and validates a single signature at a time, ensuring the signer is a registered owner.  
* **Multisig Integration**: The smart account collects signatures from multiple owners, encodes them into a signature field, and passes each for validation. The account enforces the multisig policy (e.g., 2-of-3 owners).  
* **Workflow**:  
  1. Owners submit a signature.  
  2. The smart account aggregates signatures and iterates through them, calling the Ownable Validator or WebAuthn Validator to verify each against the stored owners.  
  3. If the required number of valid signatures meets the account’s threshold, the action is approved.

## Initialization

<Tabs>
<Tab title="ECDSA">

To create a multisig account:

```ts {4}
const rhinestoneAccount = await rhinestone.createAccount({
  owners: {
    type: 'ecdsa',
    accounts: [accountA, accountB, accountC],
  },
})
```

You can also specify the signature threshold (i.e., how many signatures are required to authorize the transaction):

```ts {5}
const rhinestoneAccount = await rhinestone.createAccount({
  owners: {
    type: 'ecdsa',
    accounts: [accountA, accountB, accountC],
    threshold: 2,
  },
})
```

By default, the `threshold` is 1 (any multisig owner can sign any transaction).

</Tab>
<Tab title="Passkeys">

To create a multisig account:

```ts {4}
const rhinestoneAccount = await rhinestone.createAccount({
  owners: {
    type: 'passkey',
    accounts: [passkeyAccountA, passkeyAccountB],
  },
})
```

You can also specify the signature threshold (i.e., how many signatures are required to authorize the transaction):

```ts {5}
const rhinestoneAccount = await rhinestone.createAccount({
  owners: {
    type: 'passkey',
    accounts: [passkeyAccountA, passkeyAccountB],
    threshold: 2,
  },
})
```

By default, the `threshold` is 1 (any multisig owner can sign any transaction).

</Tab>
</Tabs>

## Usage

### Signer Selection

For 1-of-n and m-of-n multisigs, you usually want to sign the transaction with a subset of owners instead of using all of them. You can choose which signers to use with `signers`:

```ts {6-10}
const transaction = await rhinestoneAccount.sendTransaction({
  chain,
  calls: [
    // …
  ],
  signers: {
    type: 'owner',
    kind: 'ecdsa',
    accounts: [accountB],
  },
})
```

<Note>Make sure to provide enough signers to meet the threshold; otherwise, the transaction validation will fail.</Note>

## Management

### Add Signer

To add a new signer to your multisig:

<Tabs>
<Tab title="ECDSA">

```ts
import { addOwner } from '@rhinestone/sdk/actions/ecdsa'

// Add a new owner
const addOwnerTransaction = await rhinestoneAccount.sendTransaction({
  chain,
  calls: [addOwner(accountD.address)],
})
```

</Tab>
<Tab title="Passkeys">

```ts
import { addOwner } from '@rhinestone/sdk/actions/passkeys'

const pubKeyX = BigInt(slice(passkeyAccountC.publicKey, 0, 32))
const pubKeyY = BigInt(slice(passkeyAccountC.publicKey, 32))
const requiresUV = false;

// Add a new owner
const addOwnerTransaction = await rhinestoneAccount.sendTransaction({
  chain,
  calls: [addOwner(pubKeyX, pubKeyY, requiresUV)],
})
```

</Tab>
</Tabs>

### Remove Signer

To remove an existing signer from your multisig:

<Tabs>
<Tab title="ECDSA">

```ts
import { removeOwner } from '@rhinestone/sdk/actions/ecdsa'

// Remove an owner
const removeOwnerTransaction = await rhinestoneAccount.sendTransaction({
  chain,
  calls: [removeOwner(accountC.address)],
})
```

</Tab>
<Tab title="Passkeys">

```ts
import { removeOwner } from '@rhinestone/sdk/actions/passkeys'

// Remove an owner
const removeOwnerTransaction = await rhinestoneAccount.sendTransaction({
  chain,
  calls: [removeOwner(pubKeyX, pubKeyY)],
})
```

</Tab>
</Tabs>

### Change Threshold

To update the signature threshold for your multisig:

<Tabs>
<Tab title="ECDSA">

```ts
import { changeThreshold } from '@rhinestone/sdk/actions/ecdsa'

// Change threshold to 2-of-N
const changeThresholdTransaction = await rhinestoneAccount.sendTransaction({
  chain,
  calls: [changeThreshold(2)],
})
```

</Tab>
<Tab title="Passkeys">

```ts
import { changeThreshold } from '@rhinestone/sdk/actions/passkeys'

// Change threshold to 2-of-N
const changeThresholdTransaction = await rhinestoneAccount.sendTransaction({
  chain,
  calls: [changeThreshold(2)],
})
```

</Tab>
</Tabs>

### Get Owners

To retrieve the current list of owners along with the signature threshold:

```ts
// Get the list of owners
const owners = await rhinestoneAccount.getOwners(chain)
// → { "accounts": ["0xaaa…", "0xbbb…", "0xccc…"], "threshold": 2 }
```
