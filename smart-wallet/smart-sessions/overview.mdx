---
title: "Overview"
description: "Rhinestone’s framework for creating and managing session keys. It is a powerful system for creating onchain permissions."
---

## Introduction

Session keys are cryptographically signed keys generated by a user’s master key (passkey, ECDSA, or multisig). Smart Sessions enables session keys to be created and used with all major smart account implementations (via ERC-7579) and is fully compatible with Rhinestone’s Warp transaction infrastructure.

Examples of the onchain permissions that can be tailored with Smart Sessions include:
- Interacting only with a specific DeFi protocol (Aave or Uniswap)
- Spending limits on ERC20s or ETH
- Timeframes for expiry after a pre-determined period
- Combining permissions (e.g., Uniswap-only, 1000 USDC limit, 3-day expiry)

Key example use cases include:
- **Skipping confirmations**: Store a session key locally for “one-click trading,” allowing seamless decentralized application (dapp) interactions without repeated signing prompts.
- **Automating transactions**: Users share a scoped key for server-side execution, enabling:
Subscription payments
  - Limit orders or stop orders
  - Auto-repaying loans to prevent liquidation
  - This granular control enhances security, streamlines dapp interactions, and makes Web3 more user-friendly.

## How it works

[Smart Sessions](https://github.com/erc7579/smartsessions) separates **owners**, **policies**, and **actions** to increase composability and component reuse, which improves developer efficiency and costs.

## Owners

Smart Sessions support a wide range of signing mechanisms out of the box:

- [Single ECDSA key](./signature-validators/ecdsa)
- [Multiple ECDSA keys](./signature-validators/multisig) (i.e. multisig)
- [Passkeys](./signature-validators/passkey)

You can also use custom validators to validate sessions, as long as they are [ERC-7780](https://eips.ethereum.org/EIPS/eip-7780) compatible.

## Actions

Actions define what transactions (calls) you can make within a session. An action is defined by the _target address_ and the _function selector_.

An example of an action would be token transfer, where `target` would be the address of the ERC20 token and `selector` would be `0xa9059cbb` (the transfer function selector).

When defining multiple actions within a session, a transaction that matches **any** specified action is considered valid. If no actions are specified, **any** transaction will pass.

<Info>When using smart contracts directly, you need to explicitly provide a list of valid actions.</Info>

## Policies

Policies let you restrict the session to hit specific conditions. You can define policies at the _session_ (affects the entire session) or _action_ (affects a single action within a session) level.

Supported policies include:

- [Sudo](./policies/sudo): allows any transaction
- [Call](./policies/call): allows transactions with the specified calldata
- [Spending limit](./policies/spending-limit): allows a limited value of ERC20 tokens to be transferred and approved
- [Timeframe](./policies/timeframe): allows transactions within the specified time frame
- [Usage limit](./policies/usage-limit): allows a limited number of transactions
- Value limit: allows a limited ETH value transferred

When defining multiple policies within a session or an action, a transaction that passes **every** specified policy is considered valid. If no policies are specified, **any** transaction will pass (i.e., the sudo policy is applied).

### Signing policies

You can also set up the [ERC-7739](https://eips.ethereum.org/EIPS/eip-7739) policies for clear signing with sessions.

Here's an example of allowing the session to sign the `TransferWithAuthorization` requests for USDC:

```ts {18-27}
import {domainSeparator} from 'viem'

const usdcDomain = {
  name: 'USDC',
  version: '2',
  chainId: chain.id,
  verifyingContract: usdcAddress,
} as const
const usdcDomainSeparator = domainSeparator({
  domain: usdcDomain,
})
const session: Session = {
  owners: {
    type: 'ecdsa',
    accounts: [sessionOwnerAccount],
  },
  chain,
  signing: {
    allowedContent: [
      {
        domainSeparator: usdcDomainSeparator,
        contentName: [
          'TransferWithAuthorization(address from,address to,uint256 value,uint256 validAfter,uint256 validBefore,bytes32 nonce)',
        ],
      },
    ],
  },
}
```

You can then use the [signing utilties](../advanced/message-signing#typed-data-eip-712) to sign the transfer authorization on behalf of the account:

```ts
const authorizationSignature = await rhinestoneAccount.signTypedData(
  {
    domain: usdcDomain,
    types: {
      TransferWithAuthorization: [
        { name: 'from', type: 'address' },
        { name: 'to', type: 'address' },
        { name: 'value', type: 'uint256' },
        { name: 'validAfter', type: 'uint256' },
        { name: 'validBefore', type: 'uint256' },
        { name: 'nonce', type: 'bytes32' },
      ],
    },
    primaryType: 'TransferWithAuthorization',
    message: {
      from: address,
      to: receiver,
      value: 42,
      validAfter: 0,
      validBefore: validBefore,
      nonce,
    },
  },
  chain,
  {
    type: 'session',
    session,
  },
)
```

## Usage

<Note>At the moment, using smart sessions requires setting up [the ERC-4337 infrastructure](../advanced/use-erc-4337).</Note>

### Creating sessions

To create an account with a session key:

```ts {1-6,16}
const session: Session = {
  owners: {
    type: 'ecdsa',
    accounts: [sessionOwnerAccount],
  },
}

const rhinestone = new RhinestoneSDK({
  apiKey: rhinestoneApiKey,
})
const rhinestoneAccount = await rhinestone.createAccount({
  owners: {
    type: 'ecdsa',
    accounts: [ownerAccount],
  },
  sessions: [session],
})
```

You can also limit the session to specific allowed actions:

```ts {6-16}
const session: Session = {
  owners: {
    type: 'ecdsa',
    accounts: [sessionOwnerAccount],
  },
  actions: [
    {
      target: usdcAddress,
      selector: toFunctionSelector(
        getAbiItem({
          abi: erc20Abi,
          name: 'transfer',
        }),
      ),
    },
  ],
}
```

Finally, you can specify policies at both session and action levels:

```ts {6-10,20-31}
const session: Session = {
  owners: {
    type: 'ecdsa',
    accounts: [sessionOwnerAccount],
  },
  policies: [
    {
      type: 'sudo',
    },
  ],
  actions: [
    {
      target: usdcAddress,
      selector: toFunctionSelector(
        getAbiItem({
          abi: erc20Abi,
          name: 'transfer',
        }),
      ),
      policies: [
        {
          type: 'universal-action',
          rules: [
            {
              condition: 'equal',
              calldataOffset: 0n,
              referenceValue: '0xd8da6bf26964af9d7eed9e03e53415d37aa96045',
            },
          ],
        },
      ],
    },
  ],
}
```

### Installing sessions

To enable a session:

```ts
const transactionResult = await rhinestoneAccount.sendUserOperation({
  chain,
  calls: [enableSession(session)],
})
```

### Using sessions

To authorize a transaction with a session key you've enabled before:

```ts {13-16}
const transactionResult = await rhinestoneAccount.sendUserOperation({
  chain,
  calls: [
    {
      to: usdcAddress,
      data: encodeFunctionData({
        abi: erc20Abi,
        functionName: 'transfer',
        args: ['0xd8da6bf26964af9d7eed9e03e53415d37aa96045', 1n],
      }),
    },
  ],
  signers: {
    type: 'session',
    session: session,
  },
})
```

This will prompt the signature request from the session owner(s) and submit the transaction on their behalf.

<Note>You can also enable and use the smart session in one transaction using the ["enable mode"](./multi-session-signature).</Note>

## Security

Smart Sessions is a powerful tool that unlocks a bunch of new opportunities and use cases. To keep your users secure when using sessions, follow these guidelines:

* Store the session key securely. Depending on the use case, you can opt to store it in the browser or on your backend. Consider key management solutions like [KMS](https://aws.amazon.com/kms/) or [Lit Protocol](https://www.litprotocol.com).  
* Stick to the [principle of least privilege](https://en.wikipedia.org/wiki/Principle_of_least_privilege): do not request more actions than you need.  
* Guard your smart session with granular policies (e.g., restrict the amount of ETH that can be transacted through the session)  
* If possible, timebox your session (e.g., make it valid for only 1 week)

<Warning>By default, the SDK creates a session that allows any transaction. Make sure you restrict it with relevant actions and policies.</Warning>

[Reach out to us](http://t.me/kurt_larsen) if you need any help!
