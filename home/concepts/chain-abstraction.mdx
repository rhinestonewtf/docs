---
title: "Chain Abstraction"
mode: "wide"
description: "Eliminate chains, bridging, and gas "
---

<video src="/images/omni-account-chain-abstraction.mp4" muted autoPlay loop />

Chain abstraction is the natural evolution of [account abstraction](./smart-accounts). Where account abstraction aims to abstract the complexities of self-custody from the end user (seed phases, gas, etc), chain abstraction aims to take this a step further and eliminate the user’s need to understand what blockchain they are transacting on.

Rhinestone intents are most powerful when combined with a smart wallet to create a completely chain-abstracted experience for the end user. No bridging. No gas. Examples of this include:

- Lend ETH on Base using USDC on Ethereum L1 and Polygon
- Purchase an NFT on Polygon using ETH on Optimism
- Swap USDC to DEGEN using ETH from Arbitrum

## Key Features

### General-purpose Transaction Infrastructure

All smart accounts require transaction infrastructure, even smart EOAs (via EIP-7702). This is the reason ERC-4337 exists. Rhinestone utilizes relayers to support both same-chain and crosschain transactions. This is a huge DevX improvement! One toolkit for all your smart wallet needs.

Read about [Intents vs ERC-4337](./intents-and-erc4337).

### Wide Account Support

Rhinestone provides the only chain abstraction system that does not lock developers into a specific account implementation. It is compatible with all smart account implementations and EOAs. This not only provides more freedom to developers but also allows applications to support a wider array of users with an existing smart wallet.

Check out our [supported smart accounts](../../sdk/customize/smart-account-providers/nexus).

### One Signature with M-to-1 Chains and Tokens 

Mix multiple input tokens, source chains, and settlement layers within a single intent. All within one signature. This allows for a truly chain-abstracted balance where intents can be funded from any support chain and with any supported token. Rhinestone aggregates existing settlement layers to provide an extensive chain abstraction service.

### Atomic and Deterministic 

Even with M-to-1 chains and tokens, and with multiple settlement layers, Rhinestone intents are atomic and deterministic. This provides a one-click experience to the end user and allows for arbitrary calldata (such as a DEX swap or DeFi interaction) to be included in the crosschain intent with guaranteed execution (because there is no slippage).

### Incredibly low latency

Rhinestone utilizes resource locks to provide unparalleled speed. User funds are pre-locked, allowing relayers to optimistically fill crosschain intents and then process the claim against the users’ origin chain account(s). This allows fills to occur in 1-2 seconds from being posted. We also provide a pre-confirmation service that allows relayers to inform applications when an intent has been successfully submitted to the chain.

Visit the [Rhinestone Intents](../introduction/rhinestone-intents) for a more thorough intent flow walkthrough.
