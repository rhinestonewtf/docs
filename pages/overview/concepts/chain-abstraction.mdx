---
title: "Chain Abstraction"
mode: "wide"
description: "Instant crosschain intents without the need for bridging or gas tokens"
---

Rhinestone’s core product offering is Omni Account, an intent-powered system that chain abstracts any compatible smart account or EOA (via EIP-7702). Omni Account makes the underlying chain completely invisible to the end user through seamless crosschain intents. 

These crosschain intents allows users to instantly spend tokens from one chain (or multiple chains) on another chain, without bridging or without caring for the destination chain gas token. Example use cases include:

- Lend ETH on Base using USDC on Ethereum Mainnet and Polygon
- Purchase an NFT on Polygon using ETH on Optimism
- Swap USDC to DEGEN using ETH from Arbitrum 

## Key Features

- **Wide Account Support:** Unlike all other Chain Abstraction solutions, Omni Account is compatible with all major smart account implementations and smart EOAs (via EIP-7702).   
- **Atomic and Deterministic:** Any arbitrary calldata can be appended to the crosschain intent for crosschain executions. These crosschain transactions are atomic and deterministic (i.e., zero slippage) because the solver performs the destination chain transaction before claiming funds from the users source chain accounts.
- **Incredibly low latency:** Omni Account utilize resource locks and aggregates settlement layers (such as Across and Relay) to provide unparalleled speed. We provide optimal routing to give you best-in-class speed and pricing. 
- **Multiple source chains:** M-to-1 source chain to destination chain, and M-to-n input tokens to output tokens. Use an arbitrary number of origin chains and tokens to fund a single intent on a single destination chain.

## Omni Account

Omni Account consists of two core components; 

- **Smart Account:** This can be any supported smart account or a smart EOA. 
- **Omni Account Modules:** A set of contracts that enforce resource locks and set verifiable execution pathways for the Orchestrator to the integrated settlement layers.

## The Orchestrator

The Orchestrator is an offchain entity that enforces resource locks and coordinates user intents with Solvers and Settelement Layers. It listens to user intents, propagates them to a solver network, creates resource lock allocations for counterparties (e.g., Solvers), and facilitates the claim process via the chosen settlement layer (e.g., Across).

The Orchestrator is trustless from the end user’s perspective. It can only interact with the Smart Account via the Settlement Executors, providing onchain verifiable execution paths. The Settlement Executors utilize the Across Protocol as the sole settlement layer, inheriting Across’ battle-tested optimistic proof system. The Orchestrator poses no liveness or censorship risk to users. An onchain escape hatch can be activated through an onchain call without a dependency on Rhinestone.

<img
  className="block dark:hidden"
  src="/images/omniaccount_8_light.png"
/>

<img
  className="hidden dark:block"
  src="/images/omniaccount_8_dark.png"
/>

## Settlement Layers

Rhinestone currently uses Across as its primary settlement layer. Over time, additional settlement layers will be integrated to expand chain coverage, token coverage, and ensure the fastest and most cost-effective routes.

### Why is Across our Primary Settlement Layer?

**Existing Solver Network and Deep Liquidity:** Across has a mature marketplace of solvers (or Relayers) that can be used to scale this new form of cross-chain intents.

**Integrated Solver Netting:** Across supports automatic solver netting by allowing fillers to claim funds using liquidity provider (LP) funds on any chain. LP yields are regulated based on the net assets entering and leaving a chain, ensuring efficient use of available liquidity.

**Trustless Settlement Process:** Across already has a mature infrastructure that utilizes optimistic proofs to secure the settlement process in a trustless way.

## Solvers

Solvers are entities that hold token inventory on each supported chain and fill intents on behalf of the user. In the Across ecosystem, Solvers are referred to as Relayers. Other Chain Abstraction systems refer to solvers as “fillers” or “market makers.”

The Omni Account system is built on Across with similar data structures and endpoints to reduce integration complexity for existing Across Relayers.

To view a reference implementation of a solver, check out our [Rhinestone Relayer repository]. The Rhinestone Relayer is a fork of the Across Relayer, which has been adapted to fill Omni Account intents. Note that this repo is still a work in progress, and better documentation will follow soon.

## Architecture

![Architecture.png](/images/Architecture.png)

Visit the [Rhinestone Intent Architecture] for a more thorough intent flow walkthrough.



---
title: "Rhinestone Intent Architecture"
mode: "wide"
sidebarTitle: "Rhinestone Intent Architecture"
description: "An overview of the Omni Account crosschain intent flow"
---

## What are intents?

Intents are expressions of desired outcomes that sophisticated third-party actors fulfil. These third-party actors are often referred to as Solvers or Relayers. A helpful metaphor is that an intent is to purchase a good on Amazon with next-day delivery, and a transaction is a detailed description of the SKU, warehouse, and delivery routes.

Intents are chain-agnostic, but with the proper settlement infrastructure and solver marketplace, intents enable fast, cheap, and generalized executions to happen across chains. Rhinestone combines intents with a self-custodial resource locking and permissioning framework that unifies a user's balance across chains to be spent instantly on any supported chain.

## How does Rhinestone use intents?

When a user wishes to transact, the wallet or application sends a “meta intent” to Rhinestone’s Omni Account service. We then construct the instruction set for the solver to fulfil the intent, which is called the “order bundle”. This order bundle is returned to the user in the form of a human-readable signature envelope, which encodes the instruction set for the intent into a single signature. The order bundle is then propagated to the solver market to be executed.

## Rhinestone Intent Flow

The below flow provides an example flow for our interactions with the Across Relayer network and the Across settlement layer.

![Omni 4 - light.png](/images/Omni4-light.png)

1. The user interacts with an app and sends an intent to the Orchestrator
2. The Orchestrator propagates the intent to a solver network (Across Relayers)
3. The winning Relayer (X) fills the intent via the Across (Destination) Spokepool
4. Destination Spokepool sends funds and (optionally) makes an execution via the Omni Account on the destination chain

At this point, the user experience ends, yet funds have not been withdrawn from the origin chain Omni Account. The second half of the flow is the claim event, which is invincible to the user. This is what allows for low-latency crosschain transactions.

5. Relayer triggers the claim event on the origin chain Omni Account
6. Omni Account releases funds to the Across (Origin) Spokepool
7. Across settles with the Relayer after matching the origin chain deposit event with the correct destination chain prefill event.
